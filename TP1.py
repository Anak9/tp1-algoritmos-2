# -*- coding: utf-8 -*-
"""Trabalho 1 de Algoritmos II.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NJ10yu0zPZ8GqdXTH1bBUn4EK9OCSh-D

# Trabalho Prático 1: Geometria computacional
**Nome:** Lucas Xavier Veneroso

**Matricula:** 2016065138

**Nome:** Sarah Oliveira Elias

**Matricula:** 2018048478

Bibliotecas Incluidas
"""

from functools import cmp_to_key
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

"""Construindo as Classes Usadas"""

class Ponto:
  def __init__(ponto,x,y,endpointFlag = None):
    ponto.x = x
    ponto.y = y
    #Flag definida por um segmento para determinar qual é o endpoint da direita e qual é o da esquerda
    ponto.endpointFlag = endpointFlag 


class Segmento:
  def __init__(seg,p0,p1,hullFlag = None):
    seg.endpointA = p0
    seg.endpointB = p1
    #Flag definida por uma envoltória para determinar à qual envoltória o segmento pertence
    seg.hullFlag = hullFlag
    #Assignment da endpointFlag baseado na posiçao relativa a x das pontas do segmento 
    if p0.x<p1.x:
      p0.endpointFlag = 0
      p1.endpointFlag = 1
    else:
      p0.endpointFlag = 1
      p1.endpointFlag = 0

"""Funcoes "Primitivas" que são mais gerais"""

# direçao relativa entre os segmentos p0p1 e p0p2
def direcao(p0, p1, p2):
  return ( (p1.x - p0.x) * (p2.y - p0.y) ) - ( (p2.x - p0.x) * (p1.y - p0.y) ) 

# quadrado da distancia entre dois pontos
def distancia(p1, p2):
  return ( (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) )

"""### Envoltória Convexa

Entrada
"""

# le os dados do github
url = "https://raw.githubusercontent.com/Anak9/data/main/banana.dat"       
file = pd.read_fwf(url, skiprows=6)

pontos = np.array([])
x = np.array([])
y = np.array([])

data = pd.DataFrame(file).to_numpy()
for line in data:
  values = line[0].split(',')
  pontos = np.append(pontos, Ponto(float(values[0]), float(values[1])))
  x = np.append(x, float(values[0]))
  y = np.append(y, float(values[1]))

plt.scatter(x.T,y.T)
plt.grid()
plt.show()

"""Encontra o ponto âncora"""

p0 = pontos[0]
for i in range(0, len(pontos)):
  if ( (pontos[i].y < p0.y) or (pontos[i].y == p0.y and pontos[i].x < p0.x) ):
    p0 = pontos[i]
    index = i

"""### Varredura de Graham

Algoritmo auxliliar para ordenação
"""

# Função para ordenar os pontos de acordo com a coordenada polar
def compara(p1, p2):
  d = direcao(p0, p1, p2)

  if (d == 0):
    if (distancia(p0, p1) <= distancia(p0, p2)):
      return 1
    else:
      return -1
  else:
    if (d > 0):
      return 1
    else:
      return -1

def graham(pontos):

  # ordena de acordo com o angulo polar em relacao ao ancora
  pontosOrdenados = sorted(pontos, key=cmp_to_key(compara))

  # retira pontos com o mesmo angulo polar
  indices = []
  pontosOrdenados = np.append(pontosOrdenados, p0)
  for i in range(1, len(pontosOrdenados) - 1):
    d = direcao(p0, pontosOrdenados[i], pontosOrdenados[i + 1])
    # mesmo angulo polar - remove o mais distante do ponto ancora
    if ( d == 0 ):
      if ( distancia(p0, pontosOrdenados[i]) > distancia(p0, pontosOrdenados[i+1]) ):
        indices.append(i+1)
      else:
        indices.append(i)
  pontos = np.delete(pontosOrdenados, indices)

  # inicia a expansao da envoltoria
  solucao = []
  solucao.append(pontos[0])
  solucao.append(pontos[1])
  solucao.append(pontos[2])

  for i in range(3, len(pontos)):
    while( direcao(solucao[-2], solucao[-1], pontos[i]) >= 0 and len(solucao) > 1 ):
      solucao.pop()
    solucao.append(pontos[i])
  
  return solucao

"""### Varredura Linear

Algoritmo para identificar intersecçao entre dois segmentos
"""

#Caso especial de ponto no segmento
def pontoNoSegmento(p0,p1,p2):
  if ((p0.x<=p2.x<=p1.x) or (p1.x<=p2.x<=p0.x)) and ((p0.y<=p2.y<=p1.y) or (p1.y<=p2.y<=p0.y)):
    return True
  return False

#Implementaçao igual à vista em aula para saber se dois segmentos se interceptam
def intersecaoSegmentos(p1,p2,p3,p4):
  d1 = direcao(p3,p4,p1)
  d2 = direcao(p3,p4,p2)
  d3 = direcao(p1,p2,p3)
  d4 = direcao(p1,p2,p4)
  if ((d1>0 and d2<0) or (d1<0 and d2>0)) and ((d3>0 and d4<0) or (d3<0 and d4>0)):
    return True
  elif d1 == 0 and pontoNoSegmento(p3,p4,p1):
    return True
  elif d2 == 0 and pontoNoSegmento(p3,p4,p2):
    return True
  elif d3 == 0 and pontoNoSegmento(p1,p2,p3):
    return True
  elif d4 == 0 and pontoNoSegmento(p1,p2,p4):
    return True
  else: return False

"""Algoritmo de Varredura Linear em um Conjunto de Segmentos para identificar interseção"""

#Confere se há um segmento acima dado um vetor T e o segmento atual e qual é esse segmento
def acima(T,s):
  position = T.index(s)
  if position == 0:
    return False , 0
  else: return True , T[position-1]

#Confere se há um segmento abaixo dado um vetor T e o segmento atual e qual é esse segmento
def abaixo(T,s):
  position = T.index(s)
  if position == len(T)-1:
    return False , 0
  else: return True , T[position+1]


def intersecaoConjuntoSeg(S):
  T = []
  endpoints = []
  for i in range(len(S)):
    endpoints.append([S[i].endpointA,i])
    endpoints.append([S[i].endpointB,i])
  #Sorts nessa ordem garantem criterios de desempate 
  endpoints.sort(key=lambda point: point[0].y)
  endpoints.sort(key=lambda point: point[0].endpointFlag)
  endpoints.sort(key=lambda point: point[0].x)
  for p in endpoints:
    if p[0].endpointFlag == 0:
      T.append(S[p[1]])
      existeAcima , segAcima = acima(T,S[p[1]])
      existeAbaixo , segAbaixo = abaixo(T,S[p[1]])
      if ((existeAcima and intersecaoSegmentos(S[p[1]].endpointA,S[p[1]].endpointB,segAcima.endpointA,segAcima.endpointB)) 
           or (existeAbaixo and intersecaoSegmentos(S[p[1]].endpointA,S[p[1]].endpointB,segAbaixo.endpointA,segAbaixo.endpointB))): 
        if existeAcima:
          if S[p[1]].hullFlag == None or S[p[1]].hullFlag != segAcima.hullFlag:
            return True
        elif existeAbaixo:
          if S[p[1]].hullFlag == None or S[p[1]].hullFlag != segAbaixo.hullFlag:
            return True
    else:
      existeAcima , segAcima = acima(T,S[p[1]])
      existeAbaixo , segAbaixo = abaixo(T,S[p[1]])
      if existeAcima and existeAbaixo and intersecaoSegmentos(segAcima.endpointA,segAcima.endpointB,segAcima.endpointA,segAcima.endpointB): 
        if segAcima.hullFlag == None or segAbaixo.hullFlag == None or segAcima.hullFlag != segAbaixo.hullFlag:
          return True
      T.remove(S[p[1]])
  return False

"""Algoritmo Lin Separavel"""

def criaEnvoltoria(pontos, hullFlag):
  hull = []
  for i in range(0, len(pontos)-1):
    hull.append(Segmento(pontos[i], pontos[i + 1], hullFlag))
  hull.append(Segmento(pontos[i+1], pontos[0], hullFlag))
  return hull

def LinSeparable (hull0,hull1):
  segments = []
  segments += criaEnvoltoria(hull0,0)
  segments += criaEnvoltoria(hull1,1)
  return not intersecaoConjuntoSeg(segments)
